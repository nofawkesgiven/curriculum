#+STARTUP: showall
#+TITLE: A Self-Learning, Modern Computer Science Curriculum 
#+AUTHOR: jbh
#+OPTIONS: toc:2  
* Introduction

#+BEGIN_QUOTE
"The great idea of constructive type theory is that there is no distinction between programs and proofs... Theorems are types (specifications), and proofs are programs"
(Robert Harper)
#+END_QUOTE
This guide is based on Carnagie Mellon's new curriculum, for reasons why they rewrote it from scratch see Robert Harper's [[https://existentialtype.wordpress.com/2012/08/17/intro-curriculum-update/ ][blog]] and his follow up [[https://existentialtype.wordpress.com/2011/03/21/the-dog-that-didnt-bark/][post]] on the success of the new material.
The goal of this guide is to build up to a senior undergrad level in computer science with the necessary rigorous background in fundamentals to understand academic papers in journals to continue self-learning.  

** How Long Will This Take?
Depends on [[http://lifehacker.com/5886128/how-seinfelds-productivity-secret-fixed-my-procrastination-problem][daily effort]]. Each entry is typically a class with about one semester worth of material and a regular undergrad student at any university will take [[https://www.csd.cs.cmu.edu/content/sample-undergraduate-course-sequence][5 courses]] per semester with lectures 3 days a week for each course, and be assigned large projects plus multiple extra readings. Often these readings are entire texts, with the warning "exam questions from the assigned reading are fair game".
Just make a commitment for one hour a day and see how far you get after a year. Because this guide almost exclusively uses functional programming you will write far less code and be able to complete a book like /Parallel and Sequential Algorithms/ in one semester which would be impossible in an imperative language.
The "functional" part in functional programming refers to mathematical functions, meaning functions where each input has a single output. This property then gives you referential transparency, immutability, and equational reasoning. 

** Build a Library (if you can't, use library genesis)
If you can, buy these books and start building yourself a library. Abe Books often has used copies, or global editions you can buy at significant discount. You will want them around for reference and it's good for motivation, 
you get books off your desk and into the display shelf and have a physical reference for your accomplishments. It also saves your eyes from the strain of screens. If you can't afford these then try libgen.io (Library Genesis) to get a pdf/epub. 

** How to Succeed

This anecdote by Cal Newport on how he was able to get the [[http://calnewport.com/blog/2008/11/25/case-study-how-i-got-the-highest-grade-in-my-discrete-math-class/][best grade]] in his Discrete Mathematics class involved him practicing proving every theorem given in the lectures and assigned reading 
over and over until he could comfortably pick randomly through his notes and prove something without assistance. The more [[http://calnewport.com/blog/2010/01/06/the-grandmaster-in-the-corner-office-what-the-study-of-chess-experts-teaches-us-about-building-a-remarkable-life/][deliberate practice]] you can do by completing the exercises and problem sets the 
faster you will complete this curriculum, since you will be able to skip review chapters and will spend less time working on problems as you will have gained [[https://en.wikipedia.org/wiki/Mathematical_maturity][mathematical maturity]].  

On Isaac Newton self-learning geometry:
#+BEGIN_QUOTE
 "He bought Descartes' Geometry and read it by himself .. when he was got over 2 or 3 pages he could understand no farther, than he began again and got 3 or 4 pages father till he came to another difficult place, than he began again and advanced farther and continued so doing till he made himself master of the whole without having the least light or instruction from anybody"
  (King's Cam.,Keynes MS 130.10,fol. 2/v/) 
#+END_QUOTE

* Preliminaries 
These are all optional of course if you are familiar with the material already.

** Learn How to Learn
This is a waste of time if you just watch lectures, and try one or two exercises. You will get the illusion of learning. Do as many exercises as possible, and if the course page has old exams and quizzes absolutely
do them. Teaching Assistants (TAs) exist in universities to give guidence to students correcting their errors and answer questions, which you don't have access to so use [[http://cs.stackexchange.com/][stack exchange]] instead. The only way to become an expert is learning from other experts.  

- [[https://www.coursera.org/learn/learning-how-to-learn][(Full Course) Learning How to Learn]]
 - Optional course but highly recommended.
  
** Intro to Programming 
If you've struggled with programming books in the past, worry not as this book/course has proven successs teaching a profoundly typed discipline to programming. 

- [[https://www.edx.org/course/how-code-simple-data-ubcx-htc1x][(Full Course) How to Code: Simple Data]]
 - Based on the book [[http://www.ccs.neu.edu/home/matthias/HtDP2e/][How to Design Programs (HtDP)]] 
   - There is also a Masters level [[http://www.ccs.neu.edu/course/cs5010f15/][bootcamp]] to condense HtDP  
 - Some [[https://www.cs.cmu.edu/~15131/f16/][notes]] on editors and version control (git) and how to write a good [[https://chris.beams.io/posts/git-commit/][commit comment]]
 - Part two of the course is [[https://www.edx.org/course/how-code-complex-data-ubcx-htc2x][here]] and covers Backtracking and traversing graphs
 - Optional sequel to HtDP is [[http://papl.cs.brown.edu/2016/][PAPL]] 

*** Alternative Intro
The Little Schemer series books are a Q&A format/Socratic method for learning the basics of recursion, types and other core ideas in Computer Science (read the Preface of each book). You can do the Little Schemer with pencil and paper. 

- [[http://www.ccs.neu.edu/home/matthias/BTML/][(Book) The Little MLer - Matthias Felleisen, Daniel P. Friedman]]
 - Teaches you to think recursively, and provides an introduction to the principles of types, computation, and program construction.
 - Applies to any functional language, almost all the exercises can be done in OCaml or another language with a small amount of syntactic adjustment. 

** Elementary Mathematics Survey
Build a better foundation of elementary mathematics. Go through this mathematics [[https://www.maths.cam.ac.uk/sites/www.maths.cam.ac.uk/files/pre2014/undergrad/admissions/readinglist.pdf][reading list]] from Cambridge University and choose any books that interest you, the books by T.W. Körner provide excellent
insight, and /A Concise Introduction to Pure Mathematics/ by Martin Liebeck compliments the Stillwell book.

- [[http://press.princeton.edu/titles/10697.html][(Book) Elements of Mathematics: From Euclid to Gödel - John Stillwell]]
 - A Mathematicians survey of elementary topics in Algebra, Arithmetic, Combinatorics/Discrete Math, Calculus, Probability, Logic ect.
 - Casual read for anybody interested in gaining intuition into the big picture of elementary math topics
 - If you are totally lost refer to [[http://precalculus.axler.net/][Precalculus - Sheldon Axler]] or /What is Mathematics?/ by R. Courant & H. Robbins to directly look up what you don't remember. 

** Calculus
Many courses listed here assume you have a basic Calculus background since all university students do, so often will have examples to provide insight using Calculus they expect you to be familiar with. 
It's also worth knowing Calculus for it's own sake, as the fundamental theorem of Calculus is a major breakthrough in terms of cultural importance and it's heavily used in all engineering
disciplines and for finance and AI (stats), probability (integration), optimization (differentiation), analysis, and to further build mathematical maturity by learning to solve problems.

The best way to learn math is to just jump in and look up anything you come across you don't remember instead of going back to square one and redoing everything. If you don't remember cosine/sine then 
look up the tutorials on Khan Academy or any precalculus book and attempt the exercises in the calculus book instead of spending a week redoing elementary math. The more exercises you do the better you 
will get at this material and soon will no longer need any refresher material.  
    
- [[https://openlibrary.org/works/OL10687737W/Calculus_and_analytic_geometry][(Book) Calculus & Analytic Geometry - Thomas]] 
 - You want the [[https://www.amazon.com/Calculus-Analytic-Geometry-3rd-Mathematics/dp/B0000CKUFL][third]] or [[http://a.co/a8WBwMo][fourth]] edition from the 1960s. This [[https://www.amazon.com/gp/customer-reviews/R1HJTYVOE94R83/ref=cm_cr_dp_d_rvw_ttl?ie=UTF8&ASIN=0201077795][Amazon comment]] explains the difference in the editions. The "Classic" edition is the second ed.
 - Various different printings exist, some split the book into 2 parts, other printings have both contained in one volume.  
 - This is the book Don Knuth liked so much he chose Addison-Wesley as his publisher for /The Art of Computer Programming/ series. 
  - See Gilbert Strang's [[https://ocw.mit.edu/resources/res-18-005-highlights-of-calculus-spring-2010/][Highlights of Calculus]] for a survey of calculus and more intuition if necessary. 
 - Alternatively read /Calculus: Early Transcendentals/ by James Stewart which CMU uses.
 - See [[https://math.vanderbilt.edu/schectex/commerrs/][Common Errors in Undergrad Math]] like undistributed cancellations, sign errors, confusion about notation ect.
  
** Intro to Mathematical Thinking

- [[http://www.kevinhouston.net/httlam.html][(Book) How to Think Like A Mathematician - Kevin Houston]]
 - How to read theorems and definitions, how to write proofs
 - How to read a [[https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html][research paper]]
  - Optional [[http://www.people.vcu.edu/~rhammack/BookOfProof/][Book of Proof - Hammack]] online free version

** Problem Solving 
#+BEGIN_QUOTE
  "So I went to Case, and the Dean of Case says to us, it’s a all men’s school, “Men, look at, look to the person on your left, and the person on your right. One of you isn’t going to be here next year; one of you is going to fail.” So I get to Case, and again I’m studying all the time, working really hard on my classes, and so for that I had to be kind of a machine.
  In high school, our math program wasn’t much, and I had never heard of calculus until I got to college. But the calculus book that we had was (in college) was great, and in the back of the book there were supplementary problems that weren’t assigned by the teacher. So this was a famous calculus text by a man named George Thomas (second edition), and I mention it especially because it was one of the first books published by Addison-Wesley, and I loved this calculus book so much that later I chose Addison-Wesley to be the publisher of my own book.
  Our teacher would assign, say, the even numbered problems, or something like that (from the book). I would also do the odd numbered problems. In the back of Thomas’s book he had supplementary problems, the teacher didn’t assign the supplementary problems; I worked the supplementary problems. I was scared I wouldn’t learn calculus, so I worked hard on it, and it turned out that of course it took me longer to solve all these problems than the kids who were only working on what was assigned, at first. 
  But after a year, I could do all of those problems in the same time as my classmates were doing the assigned problems, and after that /I could just coast in mathematics, because I’d learned how to solve problems/"
 ([[https://github.com/kragen/knuth-interview-2006][Don Knuth]] )
#+END_QUOTE

- [[http://wiley.com/WileyCDA/WileyTitle/productCd-EHEP003691.html][(Book) The Art and Craft of Problem Solving - Paul Zeitz]]
 - Any edition will do
 - Written by former coach of the US Math Olympiad team
 - First 3 chapters have excellent strategies, such as finding invariants, pigeonhole principal ect.
  - Other chapters are optional but are very relevant to all the material here 
 - Alternative [[https://terrytao.wordpress.com/books/solving-mathematical-problems/][read]] /Solving Mathematical Problems/ by Terence Tao for strategies

- [[https://en.wikipedia.org/wiki/How_to_Solve_It][(Wikipedia) How to Solve it - George Polya]]
 - Summary on stragies in the book, optionally read whole book
  - There is also Descartes [[https://en.wikipedia.org/wiki/Discourse_on_the_Method][Discourse On the Method]]
 
* Fundamentals I: Mathematics Core   

** Recorded Lectures
Watch these as you do the book. The CMU lectures also cover some linear algebra and Complexity Theory while the MIT lectures are great for understanding induction.

- CMU 15-251 /Great Theoretical Ideas in Computer Science/ [[https://www.youtube.com/playlist?list=PLm3J0oaFux3aafQm568blS9blxtA_EWQv][lectures]] and [[http://scs.hosted.panopto.com/Panopto/Podcast/Podcast.ashx?courseid=bcf8243e-cf18-481f-960f-3c5b26fbb69b&type=mp4][backup lectures]] and [[http://www.cs.cmu.edu/~arielpro/15251f15/notes/notes-current3.pdf][course notes]] 
- (Optional) MIT 6.042j /Mathematics for Computer Science/ [[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/][lectures]] and [[https://courses.csail.mit.edu/6.042/spring17/mcs.pdf][course notes]]

** Discrete Math with Standard ML
The merging of proof and program is what makes this a great book. If you can't get this book (you should definitely get the book) the MIT [[https://courses.csail.mit.edu/6.042/spring17/mcs.pdf][lecture notes]] will work along with some kind of introductory material on [[https://en.wikipedia.org/wiki/Naive_set_theory][Set Theory]] such as the free [[https://www.people.vcu.edu/~rhammack/BookOfProof/][Book Of Proof]]. 
Set theory will come up everywhere in future courses, like the cardinality of a finite set in relational databases, and ML syntax is similar to set notation.
You can also start 15-150 /Principles of Functional Programming/ at the same time you start discrete math. 

- [[https://cs.wheaton.edu/~tvandrun/dmfp/][(Book/Lectures) Discrete Mathematics and Functional Programming - Thomas VanDrunen]]
 - Lectures exist on the author's homepage, this book is used for a one semester university course with additional elective chapters in Graph Theory, Complexity Theory, Automata, ect. 
 - Combine these chapters with the above recorded lectures by CMU/MIT.
 - List of [[https://math.vanderbilt.edu/schectex/commerrs/][Common Errors in Undergrad Math]] like undistributed cancellations, sign errors, confusion about notation ect. if you missed it from the prelims section of this guide
  - See Robert Harper's blog post on [[https://existentialtype.wordpress.com/2017/03/04/a-proof-by-contradiction-is-not-a-proof-that-derives-a-contradiction/][proof by contradiction]]
  - Read Lambda Calculus: [[http://www.cs.cmu.edu/~rwh/papers/lctotm/cs50.pdf][The Other Turing Machine]]

*** Additional Exercises to Build Mathematical Maturity
The more practice you have the better you will understand this material

  - Go through the lecture notes for both 15-251/6.042j and try to prove the example propositions and theorems yourself
  - Try the exercises in [[http://www-cs-faculty.stanford.edu/~knuth/gkp.html][Concrete Mathematics]] for deliberate practice. It is an accessible (and rigorous) book to all levels of math backgrounds as Knuth is a good teacher. 
  - Buy a used copy (any edition) of /The Art of Computer Programming Vol 1: Fundamental Algorithms/ by Donald E. Knuth and try the exercises in 1.1 and 1.2.x chapters, and 2.3.4.x /Basic Mathematical Properties of Trees/
 
* Fundamentals II: Abstraction 
Functional programming languages support algebraic datatypes, and besides direct applications to CS this material will train your mind in reasoning about abstractions.

** Abstract Algebra I 

- [[http://www.springer.com/gp/book/9780387940991][(Book) Linear Algebra: An Introduction to Abstract Mathematics - Robert J. Valenza]]
 - Focuses on the geometric intuition of linear algebra 
 - These YouTube presentations [[https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab][here]] help with understanding the topics on a geometric level. Watch the [[https://youtu.be/kjBOesZCoqc?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab][Essence of Linear Algebra]] to see what this means
 - These [[https://www.youtube.com/playlist?list=PLIljB45xT85BhzJ-oWNug1YtUjfWp1qAp][recorded]] lectures also focus on a more geometric understanding of linear algebra by Prof N J Wildberger and go well with the Valenza text 
  - Gilbert Strang also has a full Linear Algebra intro course [[https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/][here]] with recorded lectures

** Abstract Algebra II 

- [[https://www.math.upenn.edu/~ted/371F14/hw-371SchedTab.html][(Full Course) Math-371 Abstract Algebra]]
 - Has recorded lectures which are essential as you can quickly get lost in the texts at this level of abstraction
 - Uses readings from [[https://www.math.upenn.edu/~ted/371F14/info.html#texts][three texts]]  
  - There is also this [[http://www.extension.harvard.edu/open-learning-initiative/abstract-algebra][Harvard course]] with excellent recorded lectures and uses readings from /Algebra - M. Artin/ (blue book) as a great compliment to Math-371 lectures 
 - Optional [[http://www.math.hawaii.edu/~lee/algebra/history.html][history]] of Abstract Algebra by Prof Lee Lady 

** Low Level Abstraction

#+BEGIN_QUOTE
"[Computer science] is not really about computers - and it's not about computers in the same sense that physics is not really about particle accelerators, and biology is not about microscopes and Petri dishes...and geometry isn't really about using surveying instruments. Now the reason that we think computer science is about computers is pretty much the same reason that the Egyptians thought geometry was about surveying instruments: when some field is just getting started and you don't really understand it very well, it's very easy to confuse the essence of what you're doing with the tools that you use." (Hal Abelson) 
#+END_QUOTE

This covers computer architecture from a programmer's perspective, such as how to write cache friendly code, and other optimizations for the x86-64 arch. You learn how to manually write loops in assembly 
and see how recursion works at the lowest abstraction. You learn machine code instructions, return oriented programming to bypass stack protections, the memory hierarchy, and networks. You could read K&R's 
/The C Programming Language/ for a brief intro, though this course will explain C as you go anyway and fully covers pointers at the assembly language level. 

- [[https://www.cs.cmu.edu/~213/schedule.html][(Full Course) 15-213 Intro to Computer Systems (CMU)]] 
 - Recorded lectures [[http://scs.hosted.panopto.com/Panopto/Podcast/Podcast.ashx?courseid=b96d90ae-9871-4fae-91e2-b1627b43e25e&type=mp4][here]]
 - Buy the CS:APP book, 3rd version either used or get the global version.
  - The labs (Data Lab, Bomb Lab ect) are on the [[http://csapp.cs.cmu.edu/3e/students.html][book website]]. 
 - Read this post on [[https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/][Boolean Blindness]] to not get lost in imperative programming. 
 - You can also do Unix programming in [[http://mlton.org/References.attachments/Shipman02.pdf][Standard ML(pdf)]]
 - Try the embedded security CTF [[https://microcorruption.com/login][here]] after you finish the Attack Lab.
  - (Optional) There is an OS class [[http://rust-class.org/pages/classes.html][here]] that uses [[https://www.nostarch.com/Rust][Rust]] 
  
** Data Modelling 
Abstracting data to model it however you want using advanced SQL with a standard relational dbms like SQLite.
 
- [[http://15445.courses.cs.cmu.edu/fall2017/schedule.html][(Full Course) 15-445 Database Systems (CMU)]]
 - Recorded lectures on [[https://www.youtube.com/playlist?list=PLSE8ODhjZXjYutVzTeAds8xUt1rcmyT7x][youtube]]
 - Uses readings from this [[http://db-book.com/][book]], assumes you have taken 15-213 and know some basic set theory
  - (Optional) An [[http://15721.courses.cs.cmu.edu/spring2017/schedule.html][advanced class]] w/recorded lectures on building your own dbms  

** Meta-Linguistic Abstraction (Optional Elective)
This is optional but highly recommended to see the possibilities of abstraction you can attain within a language like scheme. There's a package manager [[http://dustycloud.org/misc/talks/guix/chicagolug_2015/guix_talk.html][Guix]] and distro GuixSD. You configure packages, or your entire system with one text file using a declarative DSL, and can create full dependency graphs for exact reproduction on any other system.
You can create containers that do not require taking snapshots of virtual file storage or keeping track of imperative state. GuixSD uses a scheme init system (GNU Shepherd), which means you get all the advantages of Guile's libraries/API
and can completely abstract your system (or hundreds of servers) as just data to be manipulated in a program if you wanted. SICP also fills in any first year CompSci gaps, though it's not an introductory text it's best to read it after you have some experience programming.    

- [[http://web.mit.edu/alexmv/6.037/][(Full Course) 6.037 Structure and Interpretation of Computer Programs]]
 - Recorded lectures from the first edition of SICP [[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/][here]]
 - Read the excellent [[https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-5.html#%_chap_Temp_2][forward]] from SICP on what programming is 
  - There is a [[http://web.mit.edu/~axch/www/test_manager.html][unit test library]] for SICP as well as an online [[http://icampustutor.csail.mit.edu/6.001-public/][tutorial]]
  - SICP in [[http://www.neilvandyke.org/sicp-texi/][TeXinfo]] so you can read it in emacs 
  - Optionalread: [[http://web.mit.edu/~axch/www/art.pdf][The Art of the Propagator]] for further adventures in symbolic programming

* Fundamentals III: Functional Programming

** Principles of Functional Programming
 The 2012 version by [[http://dlicata.web.wesleyan.edu/][Dan Licata]] has the best lecture notes, optionally combine with most [[http://www.cs.cmu.edu/~15150/lect.html][recent]] course notes. 

-  [[http://www.cs.cmu.edu/~15150/previous-semesters/2012-spring/lect.html][(Lecture Notes) 15-150 Principles of Functional Programming]]   
   - "PSML Chapters" are assigned reading from this book [[http://www.cs.cmu.edu/~rwh/isml/book.pdf][Programming in Standard ML]] an excellent book that will teach you programming if you don't know it already.
    - If you want pair these notes with the recorded lectures from Unit 1 through 4 (specific to SML) at [[http://courses.cs.washington.edu/courses/cse341/16sp/#lectures][CSE341 (UW)]]
    - Do these [[https://github.com/functionalCS/labs][homework assignments and labs]] plus any exercises you find in the PSML book. Try the CSE341 [[http://courses.cs.washington.edu/courses/cse341/16sp/#homeworks][homework]] 
    - Note [[http://www.cs.cmu.edu/~15150/previous-semesters/2012-spring/tools.html][emacs setup]] also [[http://courses.cs.washington.edu/courses/cse341/16sp/#software][here]] (if you use emacs)
   - Read this post about [[https://existentialtype.wordpress.com/2016/02/22/it-is-what-it-is-and-nothing-else/][what recursion is]]

** Introduction to Parallel and Sequential Algorithms
Design, analysis and programming of sequential and parallel algorithms and data structures in a functional pseudocode similar to Standard ML.

- [[http://www.parallel-algorithms-book.com/][(Book) Parallel and Sequential Algorithms]]
  - Complete, self-contained book with exercises, check [[http://www.cs.cmu.edu/~15210/schedule.html][15-210]] course schedule for recitation pdfs and extra material
  - If you want to try the 15-210 labs [[https://github.com/kidaa/Parallel-Algorithms.git][clone this repository]], read the lab handout pdf and just erase the answers and try them yourself, they are done in SML (and difficult).
   
** Programming Language Theory
Learn the fundamental principles to the design, implementation, and application of programming languages. 
Terence Tao article [[https://terrytao.wordpress.com/career-advice/there%E2%80%99s-more-to-mathematics-than-rigour-and-proofs/][on formalism and rigor]] you want to be /Stage 3: post rigorous stage/ where you can confidently reason with intuition because you have the necessary formal background.   

- [[http://www.cs.cmu.edu/~rwh/pfpl.html][(Book) Practical Foundations for Programming Languages - Robert Harper]]
  - Read [[http://www.cs.cmu.edu/~rwh/courses/ppl/phil.html][these reasons]] for studying programming languages
  - Recorded lectures to accompany the book [[https://www.cs.uoregon.edu/research/summerschool/summer16/curriculum.php][Programming Languages Background — Robert Harper and Dan Licata]]
  - More info on Judgements (logic) [[http://www.cs.cmu.edu/~fp/courses/15816-s10/lectures/01-judgments.html][here]] and a series of recorded lectures here by Frank Pfenning on [[https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html][Basic Proof Theory]] but all this is self contained in the PFPL book.
  - Read these [[http://www.cs.cmu.edu/~rwh/courses/ppl/recitations/][recitations]] and try the assignments [[http://www.cs.cmu.edu/~rwh/courses/ppl/hws.html][here]] 
  
** Isolating Software Failure, Proving Safety and Testing
How to verify software, and strategies of programming that minimize catastrophe during failure. 

- [[https://cmu-15-316.github.io/schedule/][(Lecture Notes) 15-316 Software Foundations of Security and Privacy]]
 - Read about tests, strategies to safe program design (in OCaml), and proving safety.
 - Clone this repository to get the full course w/homework assignments:  github.com/jeanqasaur/cmu-15316-spring17.git
 

- [[http://www.cs.princeton.edu/~appel/vfa/][(Book) Verified Functional Algorithms]] 
  - Part 3 of the [[https://deepspec.org/page/SF/][Deep Specifications]] interactive book series by Andrew Appel, learn by doing.
  - Assumes you have read [[https://softwarefoundations.cis.upenn.edu/current/index.html][these]] chapters of Software Foundations Part I: Preface, Basics, Induction, Lists, Poly, Tactics, Logic, IndProp, Maps, (ProofObjects), (IndPrinciples).
   - A good introduction to Dependent Types by Dan Licata is [[https://youtu.be/LXvP1A97oAM][here]] 

** Designing Compilers (Optional Elective)
The labs have starter code files that aren't public, alternative is to read the recommended chapters from the Appel book and implement the Tiger language using the lecture notes as supplemental material.
This material will really solidify your understanding of programming languages and is highly recommended. 

- [[http://www.cs.cmu.edu/~fp/courses/15411-f14/schedule.html][(Lecture Notes/Book) 15-411 Compiler Design]]
 - Implement C0 (for background info, see 15-122 [[https://www.cs.cmu.edu/~rjsimmon/15122-s16/schedule.html][lecture notes]] or the [[http://c0.typesafety.net/][specification]] of C0 which is a garbage collected C-like syntax language with an interpreter shell designed for teaching imperative language contracts 
 - Assumes you have done [[https://www.cs.cmu.edu/~213/schedule.html][15-213]] so have knowledge of stack frames
  - Uses the Andrew Appel book [[https://www.cs.princeton.edu/~appel/modern/ml/][Modern Compiler Implementation in ML]]

** Physical Systems Software Security (Optional Elective)

- [[http://symbolaris.com/course/fcps16.html][(Full Course) 15-424 Foundations of Cyber-Physical Systems]]
 - Course (with recorded lectures) if you're interested in programming drones/space shuttles/robots/cars and other things that cannot fail from avoidable errors.
 - Self contained, will teach you differential eq but assumes you already have some insight into calculus. Assumes you are somewhat familiar with invariants and [[https://www.cs.cmu.edu/~rjsimmon/15122-s16/schedule.html][programming via contracts]]

* Fundamentals IV: Algorithms & Functional Persistent Data Structures, Complexity

** Advanced Algorithms
Graduate level algorithms design course from Harvard with recorded lectures. Since you have (hopefully) already done the /Parallel and Sequential Algorithms/ book, and some linear algebra you satisfy the prerequisites. 

- [[http://people.seas.harvard.edu/~cs224/fall14/lec.html][(Full Course) CS224 Advanced Algorithms]]
- Pair this with [[http://www.cambridge.org/ca/academic/subjects/computer-science/programming-languages-and-applied-logic/purely-functional-data-structures?format=PB&isbn=9780521663502][Purely Functional Data Structures]] book by Chris Okasaki (the full book, not the thesis .pdf it's missing a lot of material)
 - Splay trees/heaps/binomial heaps/hashing ect are all in the Okasaki book as well as CS224
 - Compare both to see how to make data structures persistent
 - Also see the external links in this [[https://en.wikipedia.org/wiki/Purely_functional_data_structure#External_links][Wikipedia]] entry on persistent data structures for other material 
- Try the [[http://people.seas.harvard.edu/~cs224/fall14/hmwk.html][psets]]  

**  Undergraduate Complexity Theory 
Expands on the lectures in 15-251. This is an introduction to real theoretical computer science. 

- [[http://www.cs.cmu.edu/~15455/][(Full Course) 15-455 Undergraduate Complexity Theory]] 
 - Recorded lectures [[https://www.youtube.com/playlist?list=PLm3J0oaFux3YL5vLXpzOyJiLtqLp6dCW2][here]]
 - Uses Part III of the Sipser [[http://math.mit.edu/~sipser/itoc-derrs3.1.html][book]] /Introduction to the Theory of Computation/ 
 - A 2017 [[https://www.scottaaronson.com/papers/pnp.pdf][survey]] of the current state of P vs. NP by Scott Aaronson

*** Graduate Complexity Theory (Optional Elective) 
If you liked the above material, there's many resources to study Complexity Theory at the graduate level. You may even want to [[https://news.ycombinator.com/item?id=6346697][try solving]] one of the hard problems in this domain that doesn't have a lot of published papers. 

- [[http://www.cs.cmu.edu/~odonnell/complexity17/][(Full Course) 15-855 Graduate Computational Complexity Theory]]
 - Recorded lectures [[https://www.youtube.com/playlist?list=PLm3J0oaFux3b8Gg1DdaJOzYNsaXYLAOKH][here]]
 - Uses the [[http://theory.cs.princeton.edu/complexity/][book]] (free draft) /Computational Complexity - A Modern Approach/
 

* You're Done the Fundamentals

** Optional Extra Math   
If you feel at this level there are gaps in your mathematical understanding, There is these scribed lecture [[http://www.cs.cmu.edu/~odonnell/toolkit13/][notes]] that give you a diverse background in math useful for theoretical CS. There is also the [[https://terrytao.wordpress.com/books/analysis-i/][book series]] /Analysis I & II/ by Terence Tao 
to fill the gaps, you start at the very beginning, building up the naturals and reals. This [[http://bass.math.uconn.edu/real.html][book]] /Real Analysis for Graduate Students/ by Richard Bass is a crash course in graduate Analysis/Probability/Topology that can help fill those gaps as well. 
Real (and Complex) Analysis has many applications to [[https://simons.berkeley.edu/workshops/schedule/74][CS Theory]].   


** How to Get Better at Programming

If you want to improve your skills in the trade/craft of programming here is some [[https://www.youtube.com/watch?v=dvwkaHBrDyI][advice from Richard Stallman]]. You find a large open source project somewhere with active users, write a feature, then accept feedback from the users and more experienced  project members. Repeat. 
Keep repeating until you build up your skills in reasoning and writing for programs people actually use. You could also [[https://triplebyte.com/][get a job]] and learn directly from senior programmers. Jane Street Capital is a finance tech company that hires functional programmers 
worldwide, you may want to [[https://blogs.janestreet.com/interviewing-at-jane-street/][apply]] there, or any bio research lab would welcome your skills after completing the /Parallel & Sequential Algorithms/ book. The test/debug methology of most industry programming consistently produces piles of junk software, so there are 
numerous opportunities to apprentice as a [[https://www.nccgroup.trust/us/about-us/careers/current-vacancies/security-consultant/][security researcher]].  

* Graduate Research Elective: Type Theory
Read these [[http://www.cs.cmu.edu/~15751/2016-lecture1.pdf][slides]] from /A Theorist's ToolKit/ on how to find research, how to write math in LaTeX, how to give a talk, where to ask on stackexchange ect.

** Basic Proof Theory
-  Start with the [[https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html][lectures]] on /Basic Proof Theory/ by Frank Pfenning
  - These [[http://www.cs.cmu.edu/~fp/courses/15317-f09/schedule.html][15-317 Constructive Logic]] notes go with the seminar, there is another set [[http://symbolaris.com/course/constlog15-schedule.html][here]]
  - Read Martin-Löf's [[http://www.hf.uio.no/ifikk/forskning/publikasjoner/tidsskrifter/njpl/vol1no1/meaning.pdf][lecture notes]] 

** Intro to Category Theory
-  [[https://global.oup.com/academic/product/category-theory-9780199237180?cc=ca&lang=en&][(Book) Category Theory - Steve Awodey]] 
  - The most accessible introduction see [[https://www.andrew.cmu.edu/user/awodey/CT2errata2010.pdf][errata]], and recorded lectures by Steve Awodey [[http://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html][here(HQ mp4)]] or [[https://www.youtube.com/playlist?list=PLGCr8P_YncjVjwAxrifKgcQYtbZ3zuPlb][here(YouTube)]] 
  - There is also this [[https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html][seminar]] /Basic Category Theory: Semantics of Proof Theory/ by Ed Morehouse   
   - Also see this post here explaining [[https://jeremykun.com/2013/04/24/introducing-categories/][Category Theory]] and [[https://jeremykun.com/2013/05/04/categories-as-types/][as types]] in ML
  -  [[https://www.andrew.cmu.edu/user/awodey/catlog/][Notes]] on Categorical Logic

** Graduate Algebra Introduction    
-  [[http://www.math.fsu.edu/~aluffi/algebraerrata.2016/Errata.html][(Book) Algebra: Chapter 0 - Paolo Aluffi]]
  - Designed for self-learning, this is a fully self-contained, coherent treatment of graduate algebra with material from homological algebra
  - Tons of exercises, most very difficult but Aluffi is a great writer for demystifying Category Theory and Homology 
   - Lectures on Algebraic Topology [[https://www.youtube.com/watch?v=Ap2c1dPyIVo&list=PL6763F57A61FE6FE8][here]] to accompany the text (Homology intro, Groups ect).

** Type Theory Foundations
  - Read Chapters 1-12, 23 and 24 from [[http://www.seas.upenn.edu/~bcpierce/tapl/index.html][TAPL]]
  - Watch [[https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html][seminar]] on /Type Theory Foundations/ by Robert Harper
   - Pair with [[http://www.cse.chalmers.se/research/group/logic/book/book.pdf][Programming in Martin-Löf's Type Theory]] and the rest of the suggested reading

** Higher Dimensional Type Theory
Start with this [[https://youtu.be/caSOTjr1z18][talk]] /A Functional Programmer's Guide to Homotopy Type Theory/ with intro to Cubical Type Theory

- [[http://www.cs.cmu.edu/~rwh/courses/hott/][(Full Course) Homotopy Type Theory]]
 - Self-contained grad seminar with recorded lectures
  - Assigns readings from self-contained HoTT book https://homotopytypetheory.org/book/ 
  - Try the homework, see some of the [[https://ncatlab.org/homotopytypetheory/show/open+problems][open problems]] in HoTT research 
 - This [[https://leanprover.github.io/tutorial/][interactive tutorial]] uses HoTT to teach you automated theorem proving using Lean 2 software

** Further Research 

 - The Type Theory [[http://typetheorypodcast.com/][podcast]]
 - Use the [[https://en.wikipedia.org/wiki/Sci-Hub][Sci-Hub proxy]] to get access to journals in [[https://www.journals.elsevier.com/journal-of-applied-logic][Applied Logic]] or [[https://www.cambridge.org/core/journals/journal-of-functional-programming][Functional Programming]] or visit a local library to ask for a printing, in a few cases the authors of a paper have a draft copy on their personal pages as well 
 - Look up your closest university's event listings for the Mathematics or Computer Science departments to find seminars, these are open to the public usually and as stated in the intro you can only become an expert by learning from other experts
 - Try an advanced course in [[https://www.cs.cmu.edu/~fp/courses/15816-s10/schedule.html][Modal]] or [[http://www.cs.cmu.edu/~fp/courses/15816-f16/schedule.html][Substructural]] logic or [[http://www.cs.cmu.edu/~fp/courses/15816-s12/schedule.html][Linear]] type theory
 - Follow the research on Cubical Higher Type theory as a [[https://existentialtype.wordpress.com/2016/07/31/cubical-higher-type-theory-as-a-programming-language/][programming language]] 
 
* Graduate Research Elective: Machine Learning
Read these [[http://www.cs.cmu.edu/~15751/2016-lecture1.pdf][slides]] from /A Theorist's ToolKit/ on how to find research, how to write math in LaTeX, how to give a talk, where to ask on stackexchange ect.

** Graduate Introduction to ML
- [[http://www.cs.cmu.edu/~ninamf/courses/601sp15/lectures.shtml][(Full Course) 10-601 Masters Introduction to ML]]
 - Recorded lectures and recitations
 - Self contained, assumes you are grad level standing so have familiarity with basic probability and algebra
 - Prepares you in the foundations to understand journals and research papers
  - You may want to also take an introduction to Statistics like Penn State's [[https://onlinecourses.science.psu.edu/stat500/][Stat-500]] or look at the Harvard Graduate Statistics Course [[http://www.stat.harvard.edu/Academics/StatTree2011grad.html][family tree]]

** Advanced Introduction to ML 

- [[http://www.cs.cmu.edu/~epxing/Class/10701/lecture.html][(Full Course) 10-701 PhD Introduction to ML]]
 - Recorded lectures, provides a more in-depth treatment
 - This [[http://www.cs.cmu.edu/~bapoczos/Classes/ML10715_2015Fall/index.html][10-715 Advanced Introduction to ML]] also has recorded lectures

** Algorithms for Big Data 

- [[http://people.seas.harvard.edu/~minilek/cs229r/fall15/index.html][(Full Course) CS229r Algorithms for Big Data]]
 - A grad level course in designing/analyzing algorithms for massive data. 
 
** Further Research
 - The [[http://www.jmlr.org/][Journal]] of Machine Learning Research
 - Go to conferences, meet with experts, attend workshops
 - Open [[http://www.chalearn.org/][challenges]] in ML 
  
* Graduate Research Elective: Cryptography
Read these [[http://www.cs.cmu.edu/~15751/2016-lecture1.pdf][slides]] from /A Theorist's ToolKit/ on how to find research, how to write math in LaTeX, how to give a talk, where to ask on stackexchange ect.

** Graduate Cryptography Intro 
This course covers post-quantum crypto, elliptic curve crypto, and is taught by premiere researcher Tanja Lange (TU/e)

- [[http://www.hyperelliptic.org/tanja/teaching/crypto16/][(Full Course) Masters Level Cryptology]]
 - Recorded lectures [[http://videocollege.tue.nl/Mediasite/Catalog/catalogs/Cryptology][here]]
 - See djb's [[https://cr.yp.to/talks.html][talks]] and papers from his personal site, and [[http://pqcrypto.org/][post-quantum crypto]] site
 
** Theoretical Cryptography

- This 2 volume [[http://www.wisdom.weizmann.ac.il/~oded/foc-book.html][book]] /The Foundations of Cryptography/ by Oded Goldreich
- Lecture [[https://math.mit.edu/classes/18.783/2017/lectures.html][notes]] and recommended [[https://math.mit.edu/classes/18.783/2017/syllabus.html][readings]] from 18.783 Elliptic Curves
- Some good course [[http://www.cs.cornell.edu/courses/cs4830/2010fa/lecnotes.pdf][notes]] on resource bound cryptography 
- Peruse the latest additions (books, lectures, papers) to the [[http://www.numbertheory.org/ntw/additions.html][Number Theory Web]] and [[http://www.numbertheory.org/ntw/N6.html][journals]] via Sci-Hub proxy
- Attend the [[https://www.iacr.org/workshops/tcc/][Theory of Cryptography Conference]] or look up previous years proceedings published by Springer through Sci-Hub 

** Applied Cryptography

- Draft [[https://crypto.stanford.edu/~dabo/cryptobook/][book]] /A Graduate Course in Applied Cryptography/ - Dan Boneh and Victor Shoup
- Lecture [[https://www.ece.cmu.edu/~ece733/schedule.html][notes]] from 18-733 Applied Cryptography 
- Read all Daniel J. Bernstein's (and Peter Gutmann's) posts on the IETF Crypto Forum Research Group [Cfrg] archive, it's a [[https://mailarchive.ietf.org/arch/msg/cfrg/E-q_6ABdKfPU5XG2N6IVAs_sNhA/?qid=435ba2be2c3db3444e338cc0259ee124][master class]] in modern [[https://mailarchive.ietf.org/arch/msg/cfrg/oOY_QNA6QMsTJHLLbUjch6-GLsc/?qid=435ba2be2c3db3444e338cc0259ee124][cryptanalysis]] and he rips apart bad standards/protocol/API designs. 
- Read /The Art of Computer Programming - Seminumerical Algorithms/ by Knuth (Vol 2) chapter on Random Numbers. These same tests are still used in crypto grad courses. Try it on every library you can find that supposedly generates random numbers 
- [[https://www.wireguard.com/formal-verification/][Read]] about the proof of the Wireguard protocol, a VPN that uses =AEAD_CHACHA20_POLY1305=

** Coding Theory
Whereas cryptography strives to render data unintelligible to all but the intended recipient, error-correcting codes attempt to ensure data is decodable despite any disruptions introduced by the medium.  

- A draft [[http://www.cse.buffalo.edu/faculty/atri/courses/coding-theory/book/][book]] on Coding Theory with some [[http://www.maths.manchester.ac.uk/~ybazlov/code/][lecture notes]]
  
** Future Research

- Follow whatever the PhD students of djb and Tanja Lange are [[https://hyperelliptic.org/tanja/students.html][working on]]
- [[https://2017.pqcrypto.org/school/schedule.html][Watch]] the lectures from the 2017 Post-Quantum Crypto Summer School 
- Read the journal of [[https://link.springer.com/journal/13389][Crypto Engineering]] (use SciHub proxy)
- Read a [[http://www.math.cmu.edu/~af1p/BOOK.pdf][book]] on Random Graphs there is a [[http://math.nsc.ru/conference/g2/g2c2/TokarevaN.pdf][connection]] between Graph Theory and Cryptography 
- Try the [[https://cryptopals.com/][Cryptopals]] challenges 
- [[https://eprint.iacr.org/2017/627.pdf][Read]] about the libgcrypt (GnuPG) full key recovery for 1024-bit RSA keys (and ~1 in 8, 2048-bit keys) via L3 cache timing due to bad advice in 1990s crypto engineering handbooks.
- Try and get into TU/e or other university graduate program, this is possible even if you don't have a bachelors degree 
